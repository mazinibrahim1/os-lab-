alias functionNum R1;
alias currentPID R2;
alias word R3;
alias blockNum R4;

if(functionNum==3)then // terminal write
	multipush(R1, R2,R3);
	R1=8;
	call MOD_0;
	multipop(R1, R2,R3);
	print word;
	multipush(R1, R2,R3);
	R1=9;
	call MOD_0;
	R4=R0;//return value of relese
	multipop(R1, R2,R3);
	return;
endif;

if(functionNum==4)then //terminal read
	multipush(R1, R2,R3);
	R1=8;
	call MOD_0;
	multipop(R1, R2,R3);
	read;
	[PROCESS_TABLE+16*currentPID+4]= WAIT_TERMINAL;
	multipush(R1, R2,R3);
	call MOD_5;
	multipop(R1, R2,R3);
	[([PTBR + 2 * word/ 512] * 512) + ((word) % 512)]=[PROCESS_TABLE+16*currentPID+8];
	return;
endif;

if(functionNum==2)then //disk load
	multipush(R1, R2,R3,R4);
	R1=3;
	call MOD_0;
	multipop(R1, R2,R3,R4);
	
	[DISK_STATUS_TABLE+1]=0;
	[DISK_STATUS_TABLE+2]=R3;
	[DISK_STATUS_TABLE+3]=R4;
	load(R3,R4);
	
	[PROCESS_TABLE+16*currentPID+4]= WAIT_DISK;
	multipush(R1, R2,R3,R4);
	call MOD_5;
	multipop(R1, R2,R3,R4);
	return;
endif;

if(functionNum == DISK_STORE) then
	alias pageNum R3;

	multipush(R0, R1, R2, R3, R4);		//Accquiring DISK
	R1 = ACQUIRE_DISK;
	R2 = [SYSTEM_STATUS_TABLE + 1];		
	call MOD_0;
	multipop(R0, R1, R2, R3, R4);

	[DISK_STATUS_TABLE + 1] = 1;		//1 for DISK_STORE (and NOT LOAD)
	[DISK_STATUS_TABLE + 2] = pageNum;
	[DISK_STATUS_TABLE + 3] = blockNum;

	store(pageNum, blockNum);

	[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 4] = WAIT_DISK;
	multipush(R0, R1, R2, R3, R4);
	call MOD_5;		//invoking scheduler after setting state to WAIT_DISK
	multipop(R0, R1, R2, R3, R4);

	return;
endif;
